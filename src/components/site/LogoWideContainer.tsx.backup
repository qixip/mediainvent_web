"use client";

import React from 'react';
import { Canvas, useFrame, useThree, useLoader } from '@react-three/fiber';
import { useRef, useCallback, useMemo, useEffect, useState } from 'react';
import { useTexture } from '@react-three/drei';
import { ChevronDown } from 'lucide-react';
import { motion } from 'framer-motion';
import * as THREE from 'three';

interface LogoMeshProps {
  rotationRef: React.MutableRefObject<{ x: number; y: number }>;
}

function LogoMesh({ rotationRef }: LogoMeshProps) {
  const meshRef = useRef<THREE.Group>(null);
  const { size } = useThree();
  const [dimensions, setDimensions] = useState({ width: 4, height: 2 });
  const [logoModel, setLogoModel] = useState<THREE.Group | null>(null);
  const [use3DModel, setUse3DModel] = useState(true);
  const [loadingFailed, setLoadingFailed] = useState(false);
  
  // Fallback texture loading
  const texture = useTexture('/logo-wide.png');
  
  // Configure texture once
  useMemo(() => {
    if (texture) {
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.needsUpdate = true;
    }
  }, [texture]);
  
  // Load OBJ+MTL model
  useEffect(() => {
    const loadModel = async () => {
      try {
        console.log('Starting 3D model load...');
        
        // Dynamically import the loaders
        const { OBJLoader } = await import('three/examples/jsm/loaders/OBJLoader.js');
        const { MTLLoader } = await import('three/examples/jsm/loaders/MTLLoader.js');
        
        console.log('Loaders imported successfully');
        
        const mtlLoader = new MTLLoader();
        const objLoader = new OBJLoader();
        
        // Load materials first
        mtlLoader.load(
          '/logo-obj.mtl',
          (materials) => {
            console.log('MTL materials loaded:', materials);
            materials.preload();
            objLoader.setMaterials(materials);
            
            // Load the OBJ model
            objLoader.load(
              '/logo-obj.obj',
              (object) => {
                console.log('OBJ model loaded:', object);
                
                // Center the model
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                console.log('Model bounds:', { center, size });
                
                object.position.sub(center);
                
                setLogoModel(object);
                console.log('Model set successfully');
              },
              (progress) => {
                console.log('OBJ loading progress:', progress);
              },
              (error) => {
                console.error('Error loading OBJ:', error);
                // Fallback to placeholder
                createFallbackModel();
              }
            );
          },
          (progress) => {
            console.log('MTL loading progress:', progress);
          },
          (error) => {
            console.error('Error loading MTL:', error);
            // Try loading OBJ without materials
            loadObjOnly();
          }
        );
      } catch (error) {
        console.error('Error loading 3D model:', error);
        createFallbackModel();
      }
    };

    const loadObjOnly = () => {
      console.log('Attempting to load OBJ without MTL...');
      import('three/examples/jsm/loaders/OBJLoader.js').then(({ OBJLoader }) => {
        const objLoader = new OBJLoader();
        objLoader.load(
          '/logo-obj.obj',
          (object) => {
            console.log('OBJ loaded without materials:', object);
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            object.position.sub(center);
            setLogoModel(object);
          },
          undefined,
          (error) => {
            console.error('Error loading OBJ only:', error);
            createFallbackModel();
          }
        );
      });
    };

    const createFallbackModel = () => {
      console.log('Creating fallback model...');
      // Create a simple textured box as fallback
      const geometry = new THREE.BoxGeometry(2, 1, 0.3);
      const material = new THREE.MeshStandardMaterial({ 
        color: '#fd4d1e',
        metalness: 0.6,
        roughness: 0.4 
      });
      const fallbackMesh = new THREE.Mesh(geometry, material);
      
      const group = new THREE.Group();
      group.add(fallbackMesh);
      setLogoModel(group);
      console.log('Fallback model created');
    };

    loadModel();
  }, []);

  // Calculate responsive dimensions based on model bounds
  useEffect(() => {
    if (!logoModel) return;
    
    const box = new THREE.Box3().setFromObject(logoModel);
    const size3D = box.getSize(new THREE.Vector3());
    const maxDimension = Math.max(size3D.x, size3D.y, size3D.z);
    
    const isMobile = size.width < 768;
    const scaleFactor = isMobile ? 2 : 3;
    const scale = scaleFactor / maxDimension;
    
    setDimensions({ width: scale, height: scale });
  }, [logoModel, size]);

  // Direct rotation application without elastic animation
  useFrame(() => {
    if (!meshRef.current) return;
    
    // Apply rotation directly for immediate response
    meshRef.current.rotation.x = rotationRef.current.x;
    meshRef.current.rotation.y = rotationRef.current.y;
  });

  // If 3D model loading failed or is disabled, use 2D texture
  if (!use3DModel || loadingFailed) {
    return (
      <mesh ref={meshRef as any} position={[0, 0, 0]}>
        <boxGeometry args={[dimensions.width, dimensions.height, 0.3]} />
        {/* Side materials */}
        {[0, 1, 2, 3].map(i => (
          <meshStandardMaterial 
            key={i}
            attach={`material-${i}`} 
            color="#fd4d1e"
            metalness={0.6} 
            roughness={0.4}
          />
        ))}
        {/* Logo faces */}
        {[4, 5].map(i => (
          <meshBasicMaterial
            key={i}
            attach={`material-${i}`}
            map={texture}
            transparent
            side={THREE.DoubleSide}
            toneMapped={false}
          />
        ))}
      </mesh>
    );
  }

  if (!logoModel) {
    // Loading placeholder - simple box while model loads
    return (
      <mesh position={[0, 0, 0]}>
        <boxGeometry args={[3, 1.5, 0.3]} />
        <meshStandardMaterial color="#fd4d1e" opacity={0.7} transparent />
      </mesh>
    );
  }

  return (
    <group ref={meshRef} position={[0, 0, 0]}>
      <primitive 
        object={logoModel.clone()} 
        scale={[dimensions.width, dimensions.width, dimensions.width]}
      />
      {/* Debug wireframe to see model bounds */}
      <mesh position={[0, 0, 0]}>
        <boxGeometry args={[dimensions.width * 2, dimensions.width * 1, dimensions.width * 0.5]} />
        <meshBasicMaterial color="#00ff00" wireframe opacity={0.3} transparent />
      </mesh>
    </group>
  );
}

// Mobile Scroll Indicator Component
function MobileScrollIndicator({ isVisible, onContinue }: { isVisible: boolean; onContinue: () => void }) {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  if (!isMobile || !isVisible) return null;

  return (
    <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-[60]">
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.9 }}
        className="relative"
      >
        {/* Black circle background */}
        <div className="w-16 h-16 bg-black/90 rounded-full flex items-center justify-center shadow-2xl border border-white/30 backdrop-blur-sm">
          {/* Animated arrow */}
          <motion.button
            onClick={onContinue}
            className="text-white hover:text-primary transition-colors focus:outline-none focus:ring-2 focus:ring-white/50 focus:ring-offset-2 focus:ring-offset-black rounded p-1"
            animate={{
              y: [0, 6, 0]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              repeatDelay: 1,
              ease: "easeInOut"
            }}
            aria-label="Continue scrolling"
          >
            <ChevronDown className="w-5 h-5" />
          </motion.button>
        </div>
      </motion.div>
    </div>
  );
}

export default function LogoWideContainer() {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const rotationRef = useRef({ x: 0, y: 0 });
  const isInteractingRef = useRef(false);
  const [dpr, setDpr] = useState(1);
  const [isMobile, setIsMobile] = useState(false);
  const [isScrollLocked, setIsScrollLocked] = useState(false);
  const [showScrollIndicator, setShowScrollIndicator] = useState(false);
  const [userDismissedLock, setUserDismissedLock] = useState(false);

  // Initialize device pixel ratio and mobile detection
  useEffect(() => {
    if (typeof window !== 'undefined') {
      setDpr(Math.min(window.devicePixelRatio, 2));
      
      const checkMobile = () => {
        const mobile = window.innerWidth < 768;
        setIsMobile(mobile);
        
        // Show indicator immediately on mobile when component mounts
        if (mobile) {
          setShowScrollIndicator(true);
        }
      };
      
      checkMobile();
      window.addEventListener('resize', checkMobile);
      
      return () => window.removeEventListener('resize', checkMobile);
    }
  }, []);

  // Handle continue scrolling
  const handleContinueScrolling = useCallback(() => {
    console.log('Unlocking scroll');
    
    // Mark that user has dismissed the lock to prevent re-locking
    setUserDismissedLock(true);
    
    // Get the scroll position before unlocking
    const scrollY = document.body.style.top;
    const scrollPosition = scrollY ? parseInt(scrollY) * -1 : 0;
    
    // Unlock scrolling
    setIsScrollLocked(false);
    setShowScrollIndicator(false);
    
    // Restore scrolling with better mobile support
    document.body.style.overflow = '';
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.left = '';
    document.body.style.right = '';
    document.body.style.width = '';
    document.body.style.height = '';
    
    // Restore scroll position
    window.scrollTo(0, scrollPosition);
    
    // Scroll to next section
    setTimeout(() => {
      const nextSection = document.querySelector('#hero');
      if (nextSection) {
        nextSection.scrollIntoView({ 
          behavior: 'smooth',
          block: 'start'
        });
      }
    }, 100);
  }, []);

  // Mobile snap-to-view functionality
  const handleSnapToView = useCallback(() => {
    if (!containerRef.current || !isMobile || userDismissedLock) return;

    const container = containerRef.current;
    const rect = container.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    
    // Calculate visibility percentage
    const visibleHeight = Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0);
    const visibilityPercentage = (visibleHeight / rect.height) * 100;
    
    // If 45% or more is visible, snap to full view
    if (visibilityPercentage >= 45 && visibilityPercentage < 80) {
      console.log(`Snapping to view - ${visibilityPercentage.toFixed(1)}% visible`);
      
      container.scrollIntoView({ 
        behavior: 'smooth',
        block: 'center'
      });
    }
  }, [isMobile, userDismissedLock]);

  // Snap-to-view effect for mobile
  useEffect(() => {
    if (!isMobile || userDismissedLock) return;

    let timeoutId: NodeJS.Timeout;

    const handleScrollForSnap = () => {
      clearTimeout(timeoutId);
      // Debounce the snap check to avoid excessive calls during scroll
      timeoutId = setTimeout(() => {
        handleSnapToView();
      }, 100);
    };

    window.addEventListener('scroll', handleScrollForSnap, { passive: true });
    
    return () => {
      clearTimeout(timeoutId);
      window.removeEventListener('scroll', handleScrollForSnap);
    };
  }, [isMobile, userDismissedLock, handleSnapToView]);

  // Advanced mobile scroll control with viewport detection
  useEffect(() => {
    if (!isMobile) {
      setShowScrollIndicator(false);
      return;
    }

    let timeoutId: NodeJS.Timeout;

    const handleVisibilityChange = () => {
      if (!containerRef.current) return;

      const container = containerRef.current;
      const rect = container.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      
      // Check if container occupies most of the viewport
      const visibleHeight = Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0);
      const visibilityRatio = visibleHeight / viewportHeight;
      
      if (visibilityRatio >= 0.8 && !isScrollLocked && !userDismissedLock) {
        // Container is mostly visible - lock scroll after short delay
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          console.log('Locking scroll - container is prominent in viewport');
          setIsScrollLocked(true);
          setShowScrollIndicator(true);
          
          // Prevent scrolling with better mobile support
          const scrollY = window.scrollY;
          document.body.style.overflow = 'hidden';
          document.body.style.position = 'fixed';
          document.body.style.top = `-${scrollY}px`;
          document.body.style.left = '0';
          document.body.style.right = '0';
          document.body.style.width = '100%';
          document.body.style.height = '100%';
        }, 500);
      } else if (visibilityRatio < 0.5 && isScrollLocked) {
        // Container is not prominent - unlock scroll
        clearTimeout(timeoutId);
        handleContinueScrolling();
      }
    };

    // Initial check
    handleVisibilityChange();
    
    // Listen for scroll and resize events
    const handleScroll = () => {
      requestAnimationFrame(handleVisibilityChange);
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('resize', handleVisibilityChange, { passive: true });
    
    return () => {
      clearTimeout(timeoutId);
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleVisibilityChange);
    };
  }, [isMobile, isScrollLocked, userDismissedLock]);

  // Enhanced rotation update with better mobile sensitivity
  const updateRotation = useCallback((clientX: number, clientY: number, isMobile: boolean) => {
    if (!containerRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // Normalize position to [-1, 1]
    const normalizedX = Math.max(-1, Math.min(1, (clientX - centerX) / (rect.width / 2)));
    const normalizedY = Math.max(-1, Math.min(1, (clientY - centerY) / (rect.height / 2)));
    
    // Mobile gets more sensitive controls
    const rotationScale = isMobile ? 0.4 : 0.3;
    
    rotationRef.current = {
      x: -normalizedY * rotationScale,
      y: normalizedX * rotationScale
    };
  }, []);

  // Reset rotation to center
  const resetRotation = useCallback(() => {
    rotationRef.current = { x: 0, y: 0 };
  }, []);

  // Desktop mouse interactions
  const handleMouseEnter = useCallback(() => {
    if (!isMobile) {
      isInteractingRef.current = true;
    }
  }, [isMobile]);

  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (!isInteractingRef.current || isMobile) return;
    updateRotation(e.clientX, e.clientY, false);
  }, [updateRotation, isMobile]);

  const handleMouseLeave = useCallback(() => {
    if (!isMobile) {
      isInteractingRef.current = false;
      resetRotation();
    }
  }, [resetRotation, isMobile]);

  // Enhanced mobile touch interactions
  useEffect(() => {
    if (!isMobile) return;
    
    const container = containerRef.current;
    if (!container) return;

    let isTracking = false;
    let initialTouch = { x: 0, y: 0 };

    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        initialTouch = { x: touch.clientX, y: touch.clientY };
        isTracking = true;
        isInteractingRef.current = true;
        updateRotation(touch.clientX, touch.clientY, true);
      }
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (!isTracking || e.touches.length !== 1) return;
      
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - initialTouch.x);
      const deltaY = Math.abs(touch.clientY - initialTouch.y);
      
      // If it's a clear horizontal gesture, prevent scrolling
      if (deltaX > deltaY && deltaX > 10) {
        e.preventDefault();
      }
      
      updateRotation(touch.clientX, touch.clientY, true);
    };

    const handleTouchEnd = () => {
      isTracking = false;
      isInteractingRef.current = false;
      resetRotation();
    };

    // Use both passive and non-passive listeners strategically
    container.addEventListener('touchstart', handleTouchStart, { passive: true });
    container.addEventListener('touchmove', handleTouchMove, { passive: false }); // Non-passive to allow preventDefault
    container.addEventListener('touchend', handleTouchEnd, { passive: true });

    return () => {
      container.removeEventListener('touchstart', handleTouchStart);
      container.removeEventListener('touchmove', handleTouchMove);
      container.removeEventListener('touchend', handleTouchEnd);
    };
  }, [isMobile, updateRotation, resetRotation]);

  // Canvas optimization for mobile
  useEffect(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      // Enable pointer events for better interaction on mobile
      canvas.style.pointerEvents = isMobile && isScrollLocked ? 'auto' : 'none';
      canvas.style.touchAction = isMobile && isScrollLocked ? 'none' : 'auto';
    }
  }, [isMobile, isScrollLocked]);

  return (
    <>
      <section 
        id="logo-container"
        className="w-full h-screen bg-[#0044a3] relative"
        ref={containerRef}
        onMouseEnter={handleMouseEnter}
        onMouseMove={handleMouseMove}
        onMouseLeave={handleMouseLeave}
        style={{ 
          touchAction: isScrollLocked ? 'none' : 'pan-y',
          overscrollBehavior: 'contain',
          WebkitOverflowScrolling: 'touch' // Better iOS support
        }}
      >
        <Canvas
          ref={canvasRef}
          camera={{ 
            position: [0, 0, 8], 
            fov: 45,
            near: 0.1,
            far: 1000
          }}
          gl={{ 
            antialias: !isMobile, // Disable antialiasing on mobile for performance
            alpha: true,
            powerPreference: 'high-performance',
            toneMapping: THREE.NoToneMapping
          }}
          dpr={isMobile ? Math.min(dpr, 1.5) : dpr} // Lower DPR on mobile
        >
          <ambientLight intensity={1.0} />
          <directionalLight 
            position={[10, 10, 5]} 
            intensity={0.3}
            castShadow
            shadow-mapSize-width={1024}
            shadow-mapSize-height={1024}
          />
          
          <fog attach="fog" args={['#f05027', 18, 30]} />
          
          <LogoMesh rotationRef={rotationRef} />
        </Canvas>
        
        <div className="absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-black/10 pointer-events-none" />
      </section>
      
      {/* Mobile Scroll Indicator */}
      <MobileScrollIndicator 
        isVisible={showScrollIndicator} 
        onContinue={handleContinueScrolling} 
      />
    </>
  );
}
